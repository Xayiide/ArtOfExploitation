gcc prog.c
objdump -D a.out | grep -A20 main.:			   # AT&T syntax
objdump -M intel -D a.out | grep -A20 main.:   # Intel syntax

You can compile something for the x86 arch by using -m32 option on gcc

gdb -q ./a.out 			# Use gdb to show t he state of the processor registers right before
						# the program starts
(gdb) break main
(gdb) run
(gdb) info registers
(gdb) quit

RAX, RCX, RDX, RBX (R for 64-bit, E for 32-bit, and only AX, CX, DX and BX for 16 and 8 bit)
	General-purpose registers.
	Accumulator, Counter, Data, Base.

RSP, RBP, RSI, RDI
	General-purpose registers.
	Stack Pointer, Base Pointer, Source Index, Destination Index. (All of them are pointers)

RIP
	Instruction Pointer.
	Points to the instruction being executed.


# We are going to use Intel syntax all along, so we must configure our tools to use this syntax:
gdb -q
(gdb) set disassembly-flavor intel
(gdb) quit
echo "set disassembly-flavor intel" > ~/.gdbinit

gcc -g prog.c 	# -g option includes extra debugging info and will give GDB access to the source code
gdb -q ./a.out
(gdb) list
(gdb) disassemble main
(gdb) break main
(gdb) run
(gdb) info register rip 	# Shortened to "i r rip"

x -> Shortcut for "examine" command

 o -> Display in octal
 x -> Display in hex
 u -> Unsigned standard base 10 decimal
 t -> Display in binary


 x/o $rip -> 077042707
 x/x $rip -> 0x00fc45c7
 x/u $rip -> 16532935
 x/t $rip -> 00000000111111000100010111000111
 x/c 	  -> When it's characters (to print, e.g, this will print them)
 x/s	  -> This will print the whole string


 x/2x $rip -> Examines 2 units at the target address
 		   -> 0x00fc45c7	0xeb000000


 b -> Single byte			(8 bits)
 h -> Half word, 2 bytes	(16 bits)
 w -> Word, 4 bytes			(32 bits)
 g -> Giant, 8 bytes		(64 bits)


x/8xb $rip (Displays 8 bytes from $rip)  -> 0xc7	0x45	0xfc	0x00	0x00	0x00	0x00	0xeb
x/8xh $rip (Displays 8 hwords from $rip) -> 0x45c7	0x00fc	0x0000	0xeb00	0x4810	0x3d8d	0x009c	0x0000
x/8xw $rip (Displays 8 words from $rip)  -> 0x00fc45c7	0xeb000000	0x3d8d4810	0x0000009c
										 -> 0xfffe93e8	0xfc4583ff	0xfc7d8301	0xb8ea7e09
x/8xg $rip (Displays 8 giants from $rip) -> 0xeb00000000fc45c7	0x0000009c3d8d4810
										 -> 0xfc4583fffffe93e8	0xb8ea7e09fc7d8301
										 -> 0x9066c3c900000000	0x41ff894156415741
										 -> 0x06e6258d4c544155	0x06e62d8d48550020

using the letter "i" (short for instruction), you can display the memory as disassembler assembly
language instruction

x/i $rip 		=> 0x5555555546b8 <main+8>:		mov    DWORD PTR [rbp-0x4],0x0 

x/2i $rip 		=> 0x5555555546b8 <main+8>:		mov    DWORD PTR [rbp-0x4],0x0
				   0x5555555546bf <main+15>:	jmp    0x5555555546d1 <main+33>

This means that the instruction $rip is pointing to starts at <main+8> and ends in <main+14>. It is 7 bytes
long. DWORD PTR [rbp-0x4],0x0 is 7 bytes long. 

x/7xb $rip -> 0x5555555546b8 <main+8>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00

This assembly inst will move the value of 0 into the memory located at the address stored in the RBP 
register, minus 4. This is where C variable "i" is stored in memory "i" is an int (4 bytes of memory in the
x86 processor). This instruccion will zero the variable "i" for the loop. If that memory is examined right
now it will contain nothing but random garbage (there are several different ways to examine the memory
at this location):



#############
# First way #
#############
i r rbp
-> 0x7fffffffe000	0x7fffffffe000   # This is the memory location
x/4xb $rbp - 4
-> 0x7fffffffdffc:	0x00	0x00	0x00	0x00
# This is what the memory location contains
x/4xb 0x7fffffffdffc
-> 0x7fffffffdffc:	0x00	0x00	0x00	0x00


##############
# Second way #
##############
print $rbp-4
-> $2 = (void *) 0x7fffffffdffc
x/4xb $2
-> 0x7fffffffdffc:	0x00	0x00	0x00	0x00
x/xw $2
-> 0x7fffffffdffc:	0x00000000

 ==\  It was already at 0, but it doesn't have to.
 ==/  Thats why it's called garbage values.


We can execute the next instruction using the command "nexti". The processor will read the inst at RIP, 
execute it and advance RIP to the next instruction

nexti
-> 0x00005555555546bf	6		for (i=0; i < 10; i++)       // Loop 10 times.
x/4xb $2
-> 0x7fffffffdffc:	0x00	0x00	0x00	0x00
x/dw $2
-> 0x7fffffffdffc:	0
i r rip
-> rip            0x5555555546bf	0x5555555546bf <main+15>
x/i $rip
-> 0x5555555546bf <main+15>:	jmp    0x5555555546d1 <main+33>

Executing two more instructions, we'll be in <main+33>. Then we'll jump to <main+17>.
<main +17> Will read direction 0x555555554764 (which presumably contains the string we want to print)
and then <main +24> will call to puts with said string.

We want to see the contents of the string, so we might do:
("Hello, world!\n") Is 14 characters long. Each char is 1 Byte, so:
x/14b 0x555555554764
-> 0x555555554764:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	44 ','	32 ' '	119 'w'
-> 0x55555555476c:	111 'o'	114 'r'	108 'l'	100 'd'	33 '!'	10 '\n'

x/s 0x555555554764
-> 0x555555554764:	"Hello, world!\n"







#############################################################################################################
												Example 2
#############################################################################################################

gcc -g -o char_array2 char_array2.c
gdb -q ./char_array2

(gdb):
list
break 6
break strcpy
break 8
run

 # We set break points before, in and after the strcpy() call


 i r rip
 -> rip            0x5555555546b8	0x5555555546b8 <main+8>

 x 5/i $rip
 => 0x5555555546b8 <main+8>:	lea    rax,[rbp-0x20]
    0x5555555546bc <main+12>:	movabs rdx,0x77202c6f6c6c6548
	0x5555555546c6 <main+22>:	mov    QWORD PTR [rax],rdx
	0x5555555546c9 <main+25>:	mov    DWORD PTR [rax+0x8],0x646c726f
    0x5555555546d0 <main+32>:	mov    WORD PTR [rax+0xc],0xa21









Into pointers:
gcc -g -o pointer pointer.c
gdb -q ./pointer
(gdb) list
break 11
run
x/xw pointer
-> 0x7fffffffdfa0:	0x6c6c6548
x/s pointer
-> 0x7fffffffdfa0:	"Hello, world!\n"
x/xw &pointer
-> 0x7fffffffdfc8:	0xffffdfa0

The string itself isnt stored in the pointer variable, only the memory address 0x7fffffffdfa0 is stored
there.
In order to see the actual data stored in the pointer variable, you must use the address-of operator (&).
The pointer variable is stored at 0x7fffffffdfc8 and contains the address 0xffffdfa0



gcc -g addressof.c
gdb -q ./a.out
(gdb) list
break 8
run
print int_var
-> $1 = 5
print &int_var
-> $2 = (int *) 0x7fffffffdfd4
print int_ptr
-> $3 = (int *) 0x7fffffffdfd4
print &int_ptr
-> $4 = (int **) 0x7fffffffdfd8

An additional unary operator called the DEFERENCE operator exists for use with pointers.
This operator returns the data found in the address the pointer is pointint to, instead of the address 
itself. It takes the form of an asterisk in front of the variable name, similar to the declaration of a 
pointer


print *int_ptr
-> $5 = 5




































##############################################################################

##############################################################################

Compiled Program's memory has 5 segments:
 · Text (code)
 · Data
 · BSS
 · Heap
 · Stack

As the program executes, the RIP is set to the first inst. The processor then
follows an execution loop that does the following:
 1. Reads inst. RIP is pointing to.
 2. Adds byte length of the inst. to the RIP.
 3. Executes inst. read in 1)
 4. Go back to 1)

If RIP is changed in step 3) (jmp or something), the processor will go back to
step 1 and read the inst. found at the address of whatever RIP was changed to.

- Write permissions is disabled in the code segment as it is not used to store
variables, only code.


- Data and BSS segments are used to store global and static program variables.
Data is filled with initialized variables, while BSS with its counterparts 
(uninitialized).

Global and static variables both are able to persist because they are stored 
in their own memory segments.

- The Heap is the segment of memory a programmer can directly control. Blocks
of memory in this segment can be allocated and used for whatever the
programmer might need. Not fixed sized. It will grow and shrink depending on 
how much memory is reserved for use. A programmer can use and free heap space
on the fly with allocation functions.
	-> It grows downward toward higher memory addresses.

- The stack is variable sized too, and is used to store local function 
variables and context during function calls. This is what GDB's backtrace
command looks at. When a program calls a function, that function will have
its own set of passed variables, and the function's code will be at a
different memory location in the code segment. The stack is used to remember
all of the passed variables, the location the RIP should return to after the 
function is finished, and all the local variables used by that function.
All of this information is stored together on the stack in what's called
"stack frame". The stack contains multiple stack frames.

The stack, as its name implies, is a stack data structure which contains stack
frames. The RSP register is used to keep track of the address of the end of
the stack, which is constantly changing as items are pushed into and popped
off of it.
	-> It grows upwards toward lower memory addresses.


When a function is called, several things are pushed into the stack in a stack frame:
RBP register - sometimes called Frame Pointer (FR) or Local Base Pointer (LB) - is used to reference local
function variables in the curent frame. Each frame contains contains the parameters to the function, its
local variables and two pointers needed to put things back to the way the were:
 1. Saved Frame Pointer (SFR):
 	Restores the RBP to its previous value
 2. Return Address
 	Restores the RIP to the next instruction found after the function call






									STACK PRACTICE

stack_example.c
gcc -m32 -g stack_example.c
gdb -q ./a.out
(gdb) disass main
disass test_function()
list main

The first few instructions of each function in the code set up the stack frame. These instructions are
called Procedure Prologue or Function Prologue. They save the frame pointer on the stack and they save the
stack memory for the local function variables.

In our case:
0x0000057e <+0>:	push   ebp
0x0000057f <+1>:	mov    ebp,esp
0x00000581 <+3>:	call   0x5a2 <__x86.get_pc_thunk.ax>
0x00000586 <+8>:	add    eax,0x1a7a
...
0x000005a0 <+34>:	leave



and in test_function:
0x00000560 <+0>:	push   ebp
0x00000561 <+1>:	mov    ebp,esp
0x00000563 <+3>:	sub    esp,0x10
0x00000566 <+6>:	call   0x5a2 <__x86.get_pc_thunk.ax>
0x0000056b <+11>:	add    eax,0x1a95

When the "call" inst is executed, the return address is pushed onto the stack and the execution flow jumps to
the start of test_function() at 0x560











Memory Segments:
----------------

If static or global vars are initialized with data, they are stored in the data memory segment.
Otherwise, they will be but in the BSS memory segment.
Memory on the heap segment must first be allocated using a memory allocation function called malloc().
Finally, remaining function variables are stored in the stack memory. Since stack can contain many different
stack frames, stack variables can maintain uniqueness within different functional contexts.


memory_segments.c






