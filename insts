gcc prog.c
objdump -D a.out | grep -A20 main.:			   # AT&T syntax
objdump -M intel -D a.out | grep -A20 main.:   # Intel syntax

You can compile something for the x86 arch by using -m32 option on gcc

gdb -q ./a.out 			# Use gdb to show t he state of the processor registers right before
						# the program starts
(gdb) break main
(gdb) run
(gdb) info registers
(gdb) quit

RAX, RCX, RDX, RBX (R for 64-bit, E for 32-bit, and only AX, CX, DX and BX for 16 and 8 bit)
	General-purpose registers.
	Accumulator, Counter, Data, Base.

RSP, RBP, RSI, RDI
	General-purpose registers.
	Stack Pointer, Base Pointer, Source Index, Destination Index. (All of them are pointers)

RIP
	Instruction Pointer.
	Points to the instruction being executed.


# We are going to use Intel syntax all along, so we must configure our tools to use this syntax:
gdb -q
(gdb) set disassembly-flavor intel
(gdb) quit
echo "set disassembly-flavor intel" > ~/.gdbinit

gcc -g prog.c 	# -g option includes extra debugging info and will give GDB access to the source code
gdb -q ./a.out
(gdb) list
(gdb) disassemble main
(gdb) break main
(gdb) run
(gdb) info register rip 	# Shortened to "i r rip"

x -> Shortcut for "examine" command

 o -> Display in octal
 x -> Display in hex
 u -> Unsigned standard base 10 decimal
 t -> Display in binary


 x/o $rip -> 077042707
 x/x $rip -> 0x00fc45c7
 x/u $rip -> 16532935
 x/t $rip -> 00000000111111000100010111000111
 x/c 	  -> When it's characters (to print, e.g, this will print them)
 x/s	  -> This will print the whole string


 x/2x $rip -> Examines 2 units at the target address
 		   -> 0x00fc45c7	0xeb000000


 b -> Single byte			(8 bits)
 h -> Half word, 2 bytes	(16 bits)
 w -> Word, 4 bytes			(32 bits)
 g -> Giant, 8 bytes		(64 bits)


x/8xb $rip (Displays 8 bytes from $rip)  -> 0xc7	0x45	0xfc	0x00	0x00	0x00	0x00	0xeb
x/8xh $rip (Displays 8 hwords from $rip) -> 0x45c7	0x00fc	0x0000	0xeb00	0x4810	0x3d8d	0x009c	0x0000
x/8xw $rip (Displays 8 words from $rip)  -> 0x00fc45c7	0xeb000000	0x3d8d4810	0x0000009c
										 -> 0xfffe93e8	0xfc4583ff	0xfc7d8301	0xb8ea7e09
x/8xg $rip (Displays 8 giants from $rip) -> 0xeb00000000fc45c7	0x0000009c3d8d4810
										 -> 0xfc4583fffffe93e8	0xb8ea7e09fc7d8301
										 -> 0x9066c3c900000000	0x41ff894156415741
										 -> 0x06e6258d4c544155	0x06e62d8d48550020

using the letter "i" (short for instruction), you can display the memory as disassembler assembly
language instruction

x/i $rip 		=> 0x5555555546b8 <main+8>:		mov    DWORD PTR [rbp-0x4],0x0 

x/2i $rip 		=> 0x5555555546b8 <main+8>:		mov    DWORD PTR [rbp-0x4],0x0
				   0x5555555546bf <main+15>:	jmp    0x5555555546d1 <main+33>

This means that the instruction $rip is pointing to starts at <main+8> and ends in <main+14>. It is 7 bytes
long. DWORD PTR [rbp-0x4],0x0 is 7 bytes long. 

x/7xb $rip -> 0x5555555546b8 <main+8>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00

This assembly inst will move the value of 0 into the memory located at the address stored in the RBP 
register, minus 4. This is where C variable "i" is stored in memory "i" is an int (4 bytes of memory in the
x86 processor). This instruccion will zero the variable "i" for the loop. If that memory is examined right
now it will contain nothing but random garbage (there are several different ways to examine the memory
at this location):



#############
# First way #
#############
i r rbp
-> 0x7fffffffe000	0x7fffffffe000   # This is the memory location
x/4xb $rbp - 4
-> 0x7fffffffdffc:	0x00	0x00	0x00	0x00
# This is what the memory location contains
x/4xb 0x7fffffffdffc
-> 0x7fffffffdffc:	0x00	0x00	0x00	0x00


##############
# Second way #
##############
print $rbp-4
-> $2 = (void *) 0x7fffffffdffc
x/4xb $2
-> 0x7fffffffdffc:	0x00	0x00	0x00	0x00
x/xw $2
-> 0x7fffffffdffc:	0x00000000

 ==\  It was already at 0, but it doesn't have to.
 ==/  Thats why it's called garbage values.


We can execute the next instruction using the command "nexti". The processor will read the inst at RIP, 
execute it and advance RIP to the next instruction

nexti
-> 0x00005555555546bf	6		for (i=0; i < 10; i++)       // Loop 10 times.
x/4xb $2
-> 0x7fffffffdffc:	0x00	0x00	0x00	0x00
x/dw $2
-> 0x7fffffffdffc:	0
i r rip
-> rip            0x5555555546bf	0x5555555546bf <main+15>
x/i $rip
-> 0x5555555546bf <main+15>:	jmp    0x5555555546d1 <main+33>

Executing two more instructions, we'll be in <main+33>. Then we'll jump to <main+17>.
<main +17> Will read direction 0x555555554764 (which presumably contains the string we want to print)
and then <main +24> will call to puts with said string.

We want to see the contents of the string, so we might do:
("Hello, world!\n") Is 14 characters long. Each char is 1 Byte, so:
x/14b 0x555555554764
-> 0x555555554764:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	44 ','	32 ' '	119 'w'
-> 0x55555555476c:	111 'o'	114 'r'	108 'l'	100 'd'	33 '!'	10 '\n'

x/s 0x555555554764
-> 0x555555554764:	"Hello, world!\n"







#############################################################################################################
												Example 2
#############################################################################################################

gcc -g -o char_array2 char_array2.c
gdb -q ./char_array2

(gdb):
list
break 6
break strcpy
break 8
run

 # We set break points before, in and after the strcpy() call


 i r rip
 -> rip            0x5555555546b8	0x5555555546b8 <main+8>

 x 5/i $rip
 => 0x5555555546b8 <main+8>:	lea    rax,[rbp-0x20]
    0x5555555546bc <main+12>:	movabs rdx,0x77202c6f6c6c6548
	0x5555555546c6 <main+22>:	mov    QWORD PTR [rax],rdx
	0x5555555546c9 <main+25>:	mov    DWORD PTR [rax+0x8],0x646c726f
    0x5555555546d0 <main+32>:	mov    WORD PTR [rax+0xc],0xa21









Into pointers:
gcc -g -o pointer pointer.c
gdb -q ./pointer
(gdb) list
break 11
run
x/xw pointer
-> 0x7fffffffdfa0:	0x6c6c6548
x/s pointer
-> 0x7fffffffdfa0:	"Hello, world!\n"
x/xw &pointer
-> 0x7fffffffdfc8:	0xffffdfa0

The string itself isnt stored in the pointer variable, only the memory address 0x7fffffffdfa0 is stored
there.
In order to see the actual data stored in the pointer variable, you must use the address-of operator (&).
The pointer variable is stored at 0x7fffffffdfc8 and contains the address 0xffffdfa0



gcc -g addressof.c
gdb -q ./a.out
(gdb) list
break 8
run
print int_var
-> $1 = 5
print &int_var
-> $2 = (int *) 0x7fffffffdfd4
print int_ptr
-> $3 = (int *) 0x7fffffffdfd4
print &int_ptr
-> $4 = (int **) 0x7fffffffdfd8

An additional unary operator called the DEFERENCE operator exists for use with pointers.
This operator returns the data found in the address the pointer is pointint to, instead of the address 
itself. It takes the form of an asterisk in front of the variable name, similar to the declaration of a 
pointer


print *int_ptr
-> $5 = 5




































##############################################################################

##############################################################################

Compiled Program's memory has 5 segments:
 · Text (code)
 · Data
 · BSS
 · Heap
 · Stack

As the program executes, the RIP is set to the first inst. The processor then
follows an execution loop that does the following:
 1. Reads inst. RIP is pointing to.
 2. Adds byte length of the inst. to the RIP.
 3. Executes inst. read in 1)
 4. Go back to 1)

If RIP is changed in step 3) (jmp or something), the processor will go back to
step 1 and read the inst. found at the address of whatever RIP was changed to.

- Write permissions is disabled in the code segment as it is not used to store
variables, only code.


- Data and BSS segments are used to store global and static program variables.
Data is filled with initialized variables, while BSS with its counterparts 
(uninitialized).

Global and static variables both are able to persist because they are stored 
in their own memory segments.

- The Heap is the segment of memory a programmer can directly control. Blocks
of memory in this segment can be allocated and used for whatever the
programmer might need. Not fixed sized. It will grow and shrink depending on 
how much memory is reserved for use. A programmer can use and free heap space
on the fly with allocation functions.
	-> It grows downward toward higher memory addresses.

- The stack is variable sized too, and is used to store local function 
variables and context during function calls. This is what GDB's backtrace
command looks at. When a program calls a function, that function will have
its own set of passed variables, and the function's code will be at a
different memory location in the code segment. The stack is used to remember
all of the passed variables, the location the RIP should return to after the 
function is finished, and all the local variables used by that function.
All of this information is stored together on the stack in what's called
"stack frame". The stack contains multiple stack frames.

The stack, as its name implies, is a stack data structure which contains stack
frames. The RSP register is used to keep track of the address of the end of
the stack, which is constantly changing as items are pushed into and popped
off of it.
	-> It grows upwards toward lower memory addresses.


When a function is called, several things are pushed into the stack in a stack frame:
RBP register - sometimes called Frame Pointer (FR) or Local Base Pointer (LB) - is used to reference local
function variables in the curent frame. Each frame contains contains the parameters to the function, its
local variables and two pointers needed to put things back to the way the were:
 1. Saved Frame Pointer (SFR):
 	Restores the RBP to its previous value
 2. Return Address
 	Restores the RIP to the next instruction found after the function call






									STACK PRACTICE

 -> stack_example.c
gcc -m32 -g stack_example.c
gdb -q ./a.out
(gdb) disass main
disass test_function()
list main

The first few instructions of each function in the code set up the stack frame. These instructions are
called Procedure Prologue or Function Prologue. They save the frame pointer on the stack and they save the
stack memory for the local function variables.

In our case:
0x0000057e <+0>:	push   ebp
0x0000057f <+1>:	mov    ebp,esp
0x00000581 <+3>:	call   0x5a2 <__x86.get_pc_thunk.ax>
0x00000586 <+8>:	add    eax,0x1a7a
...
0x000005a0 <+34>:	leave



and in test_function:
0x00000560 <+0>:	push   ebp
0x00000561 <+1>:	mov    ebp,esp
0x00000563 <+3>:	sub    esp,0x10
0x00000566 <+6>:	call   0x5a2 <__x86.get_pc_thunk.ax>
0x0000056b <+11>:	add    eax,0x1a95

When the "call" inst is executed, the return address is pushed onto the stack and the execution flow jumps to
the start of test_function() at 0x560











Memory Segments:
----------------

If static or global vars are initialized with data, they are stored in the data memory segment.
Otherwise, they will be but in the BSS memory segment.
Memory on the heap segment must first be allocated using a memory allocation function called malloc().
Finally, remaining function variables are stored in the stack memory. Since stack can contain many different
stack frames, stack variables can maintain uniqueness within different functional contexts.


 -> memory_segments.c
and
 -> heap_example.c











File Descriptors and Filestreams:
---------------------------------

Two primary ways to access files in C.
 · File Descriptors use a set of low-level I/O functions
 · Filestreams use a higher level form of buffered I/O built on the lower-level functions


Four common functions that use file descriptors:
 · open() -> opens a file for reading and returns a file descriptor. The file descriptor is just an int value
 	but it is unique among open files.
 · close() -> The file descriptor is passed as an argument, and closes the file referred by that descriptor.
 · read()
 · write()







 -> simplenote.c
-> fcntl.h and sys/stat.h
	These files define the flags used in open():
	O_RDONLY -> Open file for read only access
	O_WRONLY -> Open file for write only access
	O_RDWR   -> Open file for both read and write access
	O_APPEND -> Write data at the end of the file
	O_TRUNC  -> If the file exists, truncate the file to 0 length
	O_CREAT  -> Create the file if it doesn't exist

	The flags can be combined using the bitwise OR operator


 -> fcntl_flags.c



File Permissions:
-----------------

If O_CREATE flag is used, an additional argument is needed in case a file is created.
		Give (R)ead, (W)rite, and/or e(X)ecute permissions to the file.:_
	S_IRUSR
	S_IWUSR
	S_IXUSR
	S_IRGRP
	S_IWGRP
	S_IXGRP
	S_IROTH
	S_IWOTH
	S_IXOTH



 -> uid_demo.c
./uid_demo:
real uid: 1000
effective uid: 1000

sudo ./uid_demo:
real uid: 0
effective uid: 0

chown root:root uid_demo
chmod u+s uid_demo
./uid_demo
real uid = 1000
effective uid = 0


We are going to create an include file "hacking.h"
Thus, we can include it by:
#include "hacking.h".

When the filename is surrounded by < > (as in #include <stdio.h>), the compiler will look for the file in
standard include paths, such as /usr/include. If the filename is surrounded by quotes, the compiler will
look for it in the current directory.

 -> notetaker.c
Implements some changes to the simplenote.c program.







							Structs
							-------


There is a struct for time called tm in /usr/include/time.h
After this struct is defined, struct tm becomes a variable type.
 -> time_example.c

	The localtime_r() functions expects two pointers as an argument: one to the number of seconds since
		epoch, and other to a tm struct.

 -> time_example2.c

 	Explains the struct pointers stuff















#############################################################################################################
												Exploitation
#############################################################################################################



		Buffer Overflows
	-> overflow_example.c
		buffer_one and buffer_two are 8-byte buffers. When we try to copy "1234567890" (10 bytes) into
		buffer_two. Buffer_one is directly after buffer_two in memory, so when ten bytes are copied into
		buffer_two, the last two bytes of 90 overflow into buffer_one, and overwrite whatever was there.

		A larger buffer will overflow nto the other variables, but if a large enough buffer is used, the
		program will crash and die (try with "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" instead)

	-> exploit_notesearch.c
		This explains how you can exploit a buffer overflow error
		Generates a command string that will execute the notesearch program with a command-line argument
		between single quotes. It uses string functions to do this:
		 · strlen() to get the current length of the string (to position the buffer pointer)
		 · strcat() to concatenate the closing single quote to the end
		The system() function is used to execute the command string.

		The buffer generated between the single quotes is the real meat of the exploit. The rest is just a 
		delivery method for this poison pill of data. 
		(take into acount that chown root:root and chmod u+s had been executed on ./notesearch)

	-> auth_overflow.c
		This is the same, just input some large string and it will auth you. If you pass a really long one,
		it will auth you and also segfault your face off.

		gcc -g -o auth_overflow auth_overflow.c
		gdb -q ./auth_overflow
		(gdb) list 1
		break 9
		break 16
		run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		x/s password_buffer
		-> 0x7fffffffdf00:	"\001"
		x/x &auth_flag
		-> 0x7fffffffdf1c:	0x00
		print 0x7fffffffdf1c - 0x7fffffffdf00
		-> $1 = 28
		x/16xw password_buffer

		(This is showing that password_buffer is filled with random uninitialized data and is located at 
		0x7fffffffdf00. Examining auth_fag, we can see its value of 0 and its address. The print command
		shows the auth_flag is 28 bytes past the start of password_buffer.)

		continue
		x/s password_buffer
		-> 0x7fffffffdf00:	'A' <repeats 45 times>
		x/x &auth_flag
		-> 0x7fffffffdf1c:	0x41
		x/16xw password_buffer
		
		x/4cb password_buffer
		-> 0x7fffffffdf1c:	65 'A'	65 'A'	65 'A'	65 'A'
		
		(Ultimately, the program will treat this value as an integer, so it will be read as)
		continue

		This is a contrived example that depends on memory layout of the variables.


	-> auth_overflow2.c
		gcc -g auth_overflow2.c
		gdb -q ./a.out
		(gdb) list 1
		break 9
		break 16
		... Repeat same steps as in auth_overflow.c
		x/16w &auth_flag
		-> The first byte is 0x00000000. auth_flag is located before password_buffer in memory, so it can
		never be overwritten by an overflow in password_buffer.

		However, another execution control point exists, located after all the stack variables, so it can
		easily be overwritten (done on purpose). This mem is integral to the operation of all programs, so
		it exists in all programs, and when it's overwritten, it results in a program crash.


	-> overflow_example (again)
		gcc -g -o overflow_example overflow_example.c
		./overflow_example $(perl -e 'print "A"x9')
		-> [AFTER] buffer_two is at 0x7ffc9b9f529c and contains 'AAAAAAAAA'
           [AFTER] buffer_one is at 0x7ffc9b9f52a4 and contains 'A'
		   [AFTER] value is at 0x7ffc9b9f52ac and is 5 (0x00000005)
		gdb -q
		print 0x7ffc9b9f52ac - 0x7ffc9b9f529c
		-> $1 = 16
		./overflow_example $(perl -e 'print "A"x16 . "ABDC"')
		./overflow_example $(perl -e 'print "A"x16 . "\xef\xbe\xad\xde"')
